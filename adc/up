#!/bin/bash


set -e
shopt -s xpg_echo
cd $( dirname $0 )

postreceivehook="../../.gitolite/hooks/common/post-receive"
repositories=
provisiondir=
repo=
stage=
commitish=
defaultconfdir=../conf.d
orgconfdir="../../git-up-config"
debug=0
sync_to=


# GIT INFOS
chead=
ctag=
cpretty=
gitdir=
gitopts=
NOREV="0000000000000000000000000000000000000000"


error () {
    echo "\033[41m\033[1;33mCRITICAL: $@\033[0m" >&2
}

warn () {
	echo "\033[41m\033[1;33mWARNING: $@\033[0m" >&2
}

info () {
	echo "\033[44m\033[1;36m$@\033[0m" >&2
}

msg () {
	echo "\033[40m\033[1;36m$@\033[0m" >&2
}

msgy () { 
    echo "\033[40m\033[1;33m$@\033[0m" >&2
}

debug() {
	if [ $debug -gt 0 ]
	then
		echo "# DEBUG: [$( date -R )] <<< $@" >&2
	fi
}

is_gitolite() {
	if [ -n "$GL_USER" ]
	then
		return 0
	fi
	return 1
}

is_gitlab() {
	getent passwd | grep -q gitlab
	return $?
}

# From http://theoldschooldevops.com/2008/02/09/bash-ini-parser/
cfg_parser ()
{
	ini="$(<$1)"
	ini="${ini//[/\[}"          # escape [
	ini="${ini//]/\]}"          # escape ]
	IFS=$'\n' && ini=( ${ini} ) # convert to line-array
	ini=( ${ini[*]//;*/} )      # remove comments with ;
	ini=( ${ini[*]//#*/} )      # remove comments with #
	ini=( ${ini[*]/\    =/=} )  # remove tabs before =
	ini=( ${ini[*]/=\   /=} )   # remove tabs be =
	ini=( ${ini[*]/\ =\ /=} )   # remove anything with a space around =
	ini=( ${ini[*]/#\\[/\}$'\n'cfg.section.} ) # set section prefix
	ini=( ${ini[*]/%\\]/ \(} )    # convert text2function (1)
	ini=( ${ini[*]/=/=\( } )    # convert item to array
	ini=( ${ini[*]/%/ \)} )     # close array parenthesis
	ini=( ${ini[*]/%\\ \)/ \\} ) # the multiline trick
	ini=( ${ini[*]/%\( \)/\(\) \{} ) # convert text2function (2)
	ini=( ${ini[*]/%\} \)/\}} ) # remove extra parenthesis
	ini[0]="" # remove first element
	ini[${#ini[*]} + 1]='}'    # add the last brace
	#debug "$(echo "${ini[*]}")"
	eval "$(echo "${ini[*]}")" # eval the result
}

get_conf() {
	# do not reparse every time
	if ! type cfg.section.general >/dev/null 2>&1 
	then
		# Example: fetch or update config files
		hook pre_conf

		if [ ! -d "$orgconfdir" ]
		then
			warn "You should add your organization and projects specific config files in $orgconfdir."
		else
			debug "Update internal git-up config repository ($orgconfdir)"
			# can't use --work-tree parameter as we are in a git repository ... 
			# so I use a subshell
			( cd $orgconfdir && git pull -q --ff-only origin master )  >&2
		fi

		for confdir in $defaultconfdir $orgconfdir
		do
			for conffile in default.ini organization.ini ${repo}.default.ini ${repo}.ini 
			do
				cnf=$confdir/$conffile
				if [ -e $cnf ]
				then
					debug "Parse #$n $cnf"
					cfg_parser $cnf
				fi
			done
		done

		hook post_conf
	fi
}

hook() {
	if [ -n "$1" ]
	then
		local hookname="$1"
		local hook=
		# Can't get conf on pre_conf hook
		if [ "$hookname" = "pre_conf" ]
		then
			hook="../hooks/pre_conf"
		# any other hooks:
		else
			get_conf
			cfg.section.hooks
			hook="${!1}"
		fi
		debug "hook '$hookname' ?"
		if [ -n "$hook" ]
		then
			if [ -x "$hook" ]
			then
				debug "Call hook: $hook"
				$hook $stage $repo $gitdir || exit $?
			else
				debug "hook $1 => '$hook' : script not found."
			fi
		fi
	fi
}

local_hook() {
	cfg.section.hooks
	hook="$1"
	if [ -n "$hook" ]
	then
		if [ -d "$gitdir" ]
		then
			if [ -x "$gitdir/$local_hooks_dir/$hook" ]
			then
				debug "Call hook: $hook"
				# Call it inside a subshell
				( cd "$gitdir" && $local_hooks_dir/$hook $stage $repo )
			else
				debug "hook $1 => '$local_hooks_dir/$hook' : script not found."
			fi
		else
			warn "No gitdir ? WTF ?? [$gitdir]"
		fi
	fi
}

do_update() {
	get_conf
	cfg.section.general
	debug "do auto-update: $do_auto_update_each"
	if [ -n "$do_auto_update_each" ] && [ $do_auto_update_each -gt 0 ]
	then
		# TODO: flag + check last update
		cd ..
		debug "self-update"
		hook pre_self_update
		git pull
		if is_gitolite
		then
			if diff -q hooks/post-receive $postreceivehook
			then
				echo "Updating gitolite post-receive hook."
			#	cp -a hooks/post-receive $postreceivehook
			fi
		elif is_gitlab
		then
			warn "GITLAB is not yet supported."
		fi
		debug "self-update done."
		hook post_self_update
	else
		error "auto-update is disabled"
	fi
	exit 0
}

setup_provision() {
	get_conf
	if is_gitolite
	then
		repositories="$GL_REPO_BASE_ABS"
		provisiondir="$GL_REPO_BASE_ABS/../provisioning/$stage"
	elif is_gitlab
	then
		error "GITLAB is not yet supported."
	else
		provisiondir="../../provisioning/$stage"
	fi
	gitdir="$provisiondir/$repo"

	check_repo

	if [ ! -d "$provisiondir" ]
	then
		debug "mkdir $PWD/$provisiondir"
		mkdir -p "$provisiondir"
	fi
	export GIT_WORK_TREE="$gitdir"
	export GIT_DIR="$gitdir/.git"
	debug "work-tree=$GIT_WORK_TREE"
}

provision() {
	local cloned=0
	if [ ! -d "$provisiondir/$repo" ]
	then
		msgy "Clone $repo, please wait ..."
		if ! git clone -l -q $repositories/${repo}.git $provisiondir/$repo >&2
		then
			echo "# FATAL: unable to clone $repo."
			exit 5
		fi
		cloned=1
	fi
	debug "git fetch"
	git fetch --tags $( test $debug -eq 0 && echo -q ) origin
	git fetch $( test $debug -eq 0 && echo -q ) origin
	debug "git fetch done."

	# init on commitish
	if [ $cloned -gt 0 ]
	then
		msg "Initialize to $commitish"
		git checkout $( test $debug -eq 0 && echo -q ) -f $commitish
	fi

	chead="$( git rev-parse HEAD )"
	set +e
	# On which branch am I ?
	cbranch=$( git branch -r --contains $chead | head -1 | awk '{print $3}' | cut -d/ -f2 )
	debug "cbranch=$cbranch"
	if [ -n "$cbranch" ]
	then
		cpretty="$cbranch"
	else
		cpretty="$chead"
	fi
	ctag="$( git describe --tags --exact-match $chead 2>/dev/null )"
	if [ -n "$ctag" ]
	then
		cpretty="$ctag"
	fi
	debug "cpretty=$cpretty chead=$chead ctag='$ctag'"
	set -e

}

do_infos() {
	setup_provision
	provision

	cfg.section.on_receive
	if [ $tag_enabled -gt 0 ] && [ -n "$tag_stage" ] && [ "$tag_stage" = "$stage" ]
	then
		debug "Stage <$stage> is configured on tags."
		echo "tag=1"
		echo "tag_pattern='$tag_pattern'"
	else
		echo "tag=0"
	fi

	echo "chead='$chead'"
	echo "ctag='$ctag'"
	echo "cpretty='$cpretty'"
}

check_repo() {
	if [ -z "$repo" ]
	then
		error "repository not found."
		exit 6
	fi
	if [ -z "$stage" ]
	then
		error "stage not found."
		exit 7
	fi

	get_conf
	cfg.section.general
	
	for allowed_stage in ${allowed_stages[*]}
	do
		if [ "$stage" = "$allowed_stage" ]
		then
			return 0
		fi
	done
	if [ -d "$gitdir" ]
	then
		warn "git dir '$gitdir' exists, removing it."
		rm -rf "$gitdir"
	fi
	error "Stage <$stage> is not allowed."
	exit 8
}

# Can't use cfg_parser, it's not a real INI file ...
parse_ansible_hostfile() {
	local ansible=ansible
	local hostfile="$1"
	cfg.section.inventory
	if [ -z "$ansible" ]
	then
		ansible="ansible" # took from $PATH
	else
		# quick hack...
		if [ -z "$PYTHONPATH" ]
		then
			export PYTHONPATH="$( dirname $ansible )/../lib"
			debug "PYTHONPATH=$PYTHONPATH"
		fi
	fi
	debug "Call ansible: $ansible"
	hosts=$( $ansible --inventory "$hostfile" --list-hosts $repo | awk '{print $1}' )
	
	debug "Hosts found: $hosts"
	# master is first if not already setup
	for h in "$hosts"
	do
		if [ -z "$master" ]
		then
			master="$h"
		elif [ -z "$servers" ]
		then
			servers="$h"
		else
			servers="$servers,$h"
		fi
	done
}


set_lockfile() {
	lockfile="/tmp/git_up_${repo}_${stage}.lock"
}


check_lockfile() {
	[ -e $lockfile ]
}


wait_for_lock() {
	debug "check lock"
	set_lockfile

	trap cleanup INT QUIT TERM EXIT

	# LOCK
	while check_lockfile
	do
		cat $lockfile
		lastm=$( stat -c %Y $lockfile )
		now=$( date +%s )
		td=$(( $now - $lastm ))
		if [ $td -gt 120 ]
		then
			warn "Lock file too old (2min), removing it..."
			rm -f $lockfile
		fi
		sleep 1
	done
}


get_user() {
	if is_gitolite
	then
		echo $GL_USER
	elif is_gitlab
	then
		echo "GITLAB_USER"
	else
		echo "unknown"
	fi
}


create_lock() {
	set_lockfile
	echo "\033[43m\033[1;31m$( get_user ) is deploying '$repo' on $stage with $commitish, please wait ...\033[0m" > $lockfile
}


cleanup () {
	for file in $lockfile $difffile
	do
		test -e $file && rm -f $file
	done
}

# The below is an alternative to readlink -fn which doesn't exist on OS X
# Source: http://stackoverflow.com/a/1678636
#FULL_PATH=`python -c "import os; print(os.path.realpath('$HACKING_DIR'))"`

do_sync() {
	setup_provision
	wait_for_lock
	create_lock

	debug "Prepare to deploy ..."
	cfg.section.deploy
	if ! cfg.section.deploy-$stage 2>/dev/null
	then
		error "$repo didn't have $stage deployment configuration, or is not authorized to."
		msgy "Hint: add a configuration file $orgconfdir/${repo}.ini"
		exit 9
	fi

	if [ ! -d "$gitdir" ]
	then
		error "WTF ? gitdir not found [$gitdir]"
		exit 14
	fi

	# use inventory script if available
	if [ -n "$inventory" ]
	then
		debug "inventory=$inventory"
		# Replace REPOSITORY and STAGE parameters 
		for i in $( seq 1 ${#inventory[@]} )
		do
			inventory[$i]="$( echo "${inventory[$i]}" | sed "s/REPOSITORY/$repo/; s/STAGE/$stage/;" )"
		done

		if [ -x "$inventory" ]
		then
			debug "Call inventory script $inventory with args '${inventory[@]:1}'"
			eval $( ${inventory[@]} )
		elif [ -e "$inventory" ]
		then
			debug "Parse inventory hostfile $inventory"
			parse_ansible_hostfile $inventory
		else
			error "Inventory $inventory not found."
			exit 15
		fi
	fi

	# OK, then checkout repository to what we want
	debug "Checkout to $sync_to"
	git checkout $( test $debug -eq 0 && echo -q ) -f $sync_to

	hook "pre_deploy"
	local_hook "pre-deploy"

	if [ -z "$master" ]
	then
		error "Master not found."
		exit 16
	fi

	msg ">>> Delivering $repo to $stage on $sync_to ..."
	local sync_cmd="./git-deploy.pl
--repo=$repo
--stage=$stage
--source-dir=$gitdir
--rsync-module=$rsync_module
--rsync-user=$user
--master=$master"

	if [ $debug -gt 0 ]
	then
		sync_cmd="$sync_cmd 
--debug"
	fi

	if [ -n "$servers" ]
	then
		sync_cmd="$sync_cmd 
--servers=$servers"
	fi

	debug "$sync_cmd"
	$sync_cmd
	cleanup
}

# 
# MAIN
#
while [ $# -gt 0 ]
do
	case "$1" in
		test)
			exit 0
			;;
		autotag)
			shift
			exec ../bin/autotag.pl --nofetch --short $@
			;;
		update)
			do_update
			;;
		infos)
			do_infos
			;;
		sync)
			shift
			sync_to="$1"
			do_sync
			;;
		--debug)
			debug=1
			debug "Call $0 $@"
			;;
		--init)
			shift
			commitish="$1"
			;;
		*)
			if [ -z "$repo" ]
			then
				repo="$1"
			elif [ -z "$stage" ]
			then
				stage="$1"
			else
				echo "You are not supposed to do that, go away !"
				exit 42
			fi
			;;
	esac
	shift
done

# TODO: 
# - check that sync_to is in the future
#   else, use --force
# - ezuplog
